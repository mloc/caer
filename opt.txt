scratchpad

BIG TODO: switch is broken rn, always casts to bool before checking. basically acts as br
    FIXED probably, by inverting meaning of switches
    replaced rt_val_to_bool with rt_val_to_switch_disc, which casts to u32

scoping issues
    stuff can be descoped before we use it in a terminator

----

values
    soft and hard values
        hard values have complete type info at compile time, some way or another
            can be more directly operated on
        soft are wrapped with type info, dynamic
            need to be operated on using runtime helpers

    softval structure
        opaque enum? - for now, sure.
            in future it'd be nicer to have something we can downcast hard->soft without runtime

        problems abound
            with current stub system, is heap allocated :(
            future work for less opaque enum would help this; for now, need to remember to drop

scopes
    sketchbook musings:
        scopes are more granular than blocks? but can span blocks
        maybe not- the only case I can think of where this matters is temporary literals in if conds
        but we can assign them to the outer scope and clean up later, since they can't define vars
        only cond-ish thing that makes vars is for(;;), but this will be a block anyway
        so are scopes aligned with blocks? hopefully. if not, maybe we can split blocks up instead
        this might also help unwind cleanup
            oh yikes- how will that work? a cleanup block for every block?
        can llvm help at all?

calling (global) procs
    deferred thinking about this until we have a better idea on errors
    need to think about: args

runtime errors
    current plan: llvm exceptions
    but- we'd like to be able to propagate errors from the runtime
    could have some rtcall wrapper but that adds overhead to all rtcalls

concurrency
    llvm coroutines? haven't looked into this enough

future optimizations:
    hard values + stack soft values
        hard values need type inference (in future: annotations)

        stack values are more interesting
            starting point might be informing about size of rt::Val
            ideally we want Val to be less opaque so that we can do manipulations without hitting rt

    faster DM calls
        specialization!
        create "type strict" versions of procs when we have full type info, call when possible
            "hard" procs? procs that only take hard values
        using standard cdecly functions + args
        absence masking to handle default args without having to wrap
            positional args might take some more hacking
        won't work for any proc that uses args list
            but maybe we can specialize List<Val> to List<Int> or so
            qdel will suffer -> but maybe that can be an intrinsic? we could just improve del

        separate from dynamic/static dispatch, only affects how args are passed

        linting/annotations to ensure procs are used only strictly? "nosoft"
            affects call()() usage - that'll probably always use soft unless we keep md around
            maybe not useful, we probably still want to use hard procs from soft context
            alternatively act as a check for all values being hard?
