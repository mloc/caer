pub mod error;

use std::io::Write;
use std::result;

use caer_ir::module::Module;
use caer_types::id::FuncId;
use caer_types::type_tree::{PathType, ProcInfo};

use crate::error::GeneratorError;

type Result<T> = result::Result<T, GeneratorError>;

pub struct Generator<W: Write> {
    out: W,
}

impl<'ir, W: Write> Generator<W> {
    pub fn new(out: W) -> Self {
        Self { out }
    }

    pub fn generate(&mut self, ir: &Module) -> Result<()> {
        self.write("// AUTOGENERATED SHIM CODE\n")?;
        for dty in ir.type_tree.iter() {
            self.write_type(ir, dty)?;
            self.write("\n")?;
        }
        Ok(())
    }

    fn write<B: AsRef<[u8]>>(&mut self, buf: B) -> Result<()> {
        self.out.write_all(buf.as_ref())?;
        Ok(())
    }

    fn write_type(&mut self, ir: &Module, dty: &PathType) -> Result<()> {
        self.write_path(dty)?;
        self.write("{ \\\n")?;
        for proc in dty.iter_procs() {
            // SpacemanDMM treats sleep as a proc, but DM thinks it's a keyword, so we can't define
            // or override /proc/sleep(). It's also not a valid verb target, so we can skip
            // building a shim.
            // I don't think there's any other cases of this, but maybe this should be cleaned up
            // anyway.
            // TODO: inline stringid comparisons?
            if ir.string_table.get(proc.name) == "sleep" {
                continue;
            }
            self.write_proc(ir, proc)?;
        }
        self.write("}\n")?;
        Ok(())
    }

    fn write_path(&mut self, dty: &PathType) -> Result<()> {
        if dty.path_string.is_empty() {
            self.write("/")
        } else {
            self.write(&dty.path_string)
        }
    }

    fn write_proc(&mut self, ir: &Module, proc: &ProcInfo) -> Result<()> {
        let proc_name = ir.string_table.get(proc.name);
        let func = &ir.funcs[&proc.top_proc];
        // Bulitin procs are inherently overrides
        if !func.builtin && func.parent.is_none() {
            self.write("proc/")?;
        }
        self.write(proc_name)?;
        self.write("(){ \\\n")?;
        self.write_call(RuntimeCall::CallVerb(func.id))?;
        self.write("} \\\n")?;
        Ok(())
    }

    fn write_call(&mut self, call: RuntimeCall) -> Result<()> {
        // TODO: prefixes?
        self.write(call.format_call())?;
        self.write(" \\\n")?;
        Ok(())
    }
}

enum RuntimeCall {
    // TODO: use procids
    CallVerb(FuncId),
}

impl RuntimeCall {
    fn macro_name(&self) -> &'static str {
        match self {
            RuntimeCall::CallVerb(_) => "CALL_VERB",
        }
    }

    fn format_args(&self) -> String {
        match self {
            RuntimeCall::CallVerb(id) => id.index().to_string(),
        }
    }

    fn format_call(&self) -> String {
        format!("{}({})", self.macro_name(), self.format_args())
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let v = 2 + 2;
        assert_eq!(v, 4);
    }
}
